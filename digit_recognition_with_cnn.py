# -*- coding: utf-8 -*-
"""Digit Recognition with CNN

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IlQxX-DK8NFa-DbyJ_gob5D16v7L_fCQ
"""

import cv2
import numpy as np 
import glob
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelBinarizer
from tensorflow import keras 
from keras import models , layers
import matplotlib.pyplot as plt
plt.style.use("ggplot")
import os
from google.colab.patches import cv2_imshow
from tensorflow.keras.models import load_model

"""CNN Model For Handwritten Digit Classification"""

path="/content/10000//*//*"

def load_data_preprocess(dataset):
    
    all_images = []
    all_labels = []
    
    for i , item in enumerate(glob.glob(dataset)):
        img = cv2.imread(item)
        
        img = cv2.resize(img , (32 ,32))
        img = img/255.0
        all_images.append(img)
        
        label = item.split("/")[3]
        all_labels.append(label)

        if i % 100 == 0:
          print("[info] {}/10000 processed".format(i))
        
    all_images = np.array(all_images)
    lb = LabelBinarizer()
    all_labels = lb.fit_transform(all_labels)
    
    trainX , testX , trainY , testY = train_test_split(all_images, all_labels, test_size = 0.15)
    
    return trainX , testX , trainY , testY



def CNN():
    net = models.Sequential([ 
                             layers.Conv2D(32, (3,3), activation="relu" , padding="same" , input_shape=(32,32,3)),
                             layers.BatchNormalization(),
                             layers.MaxPooling2D((2,2)),
                             layers.Conv2D(64, (3,3), activation="relu", padding="same"),
                             layers.BatchNormalization(),
                             layers.MaxPooling2D((2,2)),
                             layers.Flatten(),
                             layers.Dense(32 , activation="selu"),
                             layers.BatchNormalization(),
                             layers.Dense(10 , activation="softmax")
                             ])
    net.compile(loss = "categorical_crossentropy",
                optimizer="Adam",
                metrics=["accuracy"]   
                )
    return net

trainX , testX , trainY , testY = load_data_preprocess(path)
net = CNN()

H = net.fit(x=trainX , y=trainY , epochs=25, batch_size=32 , validation_data=(testX , testY))

plt.plot(H.history["accuracy"], label= "train accuracy")
plt.plot(H.history["val_accuracy"], label= "test accuracy")
plt.plot(H.history["loss"], label= "train loss")
plt.plot(H.history["loss"], label= "train loss")
plt.plot(H.history["val_loss"], label= "test loss")
plt.legend()
plt.xlabel("epochs")
plt.ylabel("loss/accuracy")
plt.title("Digit_cllasifiction")
plt.show()

net.save("Digit_Cllasifire_2.h5")

"""Image Processing With CV2 and Predict Phase




"""

net = load_model("/content/drive/MyDrive/Digit_Cllasifire.h5")
img = cv2.imread("/content/drive/MyDrive/DIGIt 2.png")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

T , thresh = cv2.threshold(gray , 160 , 255 , cv2.THRESH_BINARY_INV)
cnts , _ = cv2.findContours(thresh , cv2.RETR_EXTERNAL , cv2.CHAIN_APPROX_SIMPLE)

for i in range(len(cnts)):

  x,y,w,h = cv2.boundingRect(cnts[i])

  roi = img[y-10:y+h+10 , x-10:x+w+10]
  roi = cv2.resize(roi , (32,32))
  roi = roi/255.0
  roi = np.array([roi])
  output = net.predict(roi)
  max_index = np.argmax(output)
  print(max_index)
  cv2.rectangle(img , (x-10,y-10), (x+w+10 , y+h+10), (0,255,0),2)
  cv2.putText(img, str(max_index),(x , y-10),cv2.FONT_HERSHEY_SIMPLEX , 1.2 , (0,255,0), 2)
cv2_imshow(img)
cv2.waitKey(0)




cv2.destroyAllWindows()